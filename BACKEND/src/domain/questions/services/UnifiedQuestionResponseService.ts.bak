import { firestore } from 'firebase-admin';
import { Timestamp } from 'firebase-admin/firestore';
import { v4 as uuidv4 } from 'uuid';
import {
  EnhancedQuestionResponse,
  RecordAnswerPayload,
  RecordAnswerResult,
  CreateEnhancedResponsePayload,
  UpdateEnhancedResponsePayload,
  ResponseContext,
  ReviewQuality,
  FatigueLevel,
  TimeMetrics,
  SessionMetrics
} from '../types/enhanced';
import {
  QuestionRetentionRecord,
  RetentionAttempt,
  LearningPattern
} from '../types/retention';
import {
  ListCompletionStatistics,
  TimeEfficiencyAnalysis,
  RetentionAnalysis,
  TemporalPatterns,
  IntelligentRecommendations
} from '../types/statistics';
import { FSRSService, FSRSGrade } from '../../srs/services/FSRSService';
import { QuestionRetentionService } from './QuestionRetentionService';
import { IQuestionService } from '../interfaces/IQuestionService';
import logger from '../../../utils/logger';
import AppError from '../../../utils/AppError';

const ENHANCED_QUESTION_RESPONSES_COLLECTION = 'enhancedQuestionResponses';

/**
 * Serviço unificado para gerenciamento de respostas de questões
 * 
 * FASE 4: Implementação robusta do sistema unificado
 * - Substitui FirebaseQuestionResponseService + FirebaseUserQuestionHistoryService
 * - Integração completa com FSRS
 * - Análise de retenção e eficiência temporal
 * - Recomendações inteligentes baseadas em dados
 */
export class UnifiedQuestionResponseService {
  private db: firestore.Firestore;
  private fsrsService: FSRSService;
  private retentionService: QuestionRetentionService;
  private questionService: IQuestionService;

  constructor(
    db: firestore.Firestore,
    fsrsService: FSRSService,
    retentionService: QuestionRetentionService,
    questionService: IQuestionService
  ) {
    this.db = db;
    this.fsrsService = fsrsService;
    this.retentionService = retentionService;
    this.questionService = questionService;
  }

  /**
   * Registrar resposta de questão com análise completa
   * Método principal que orquestra todas as funcionalidades
   */
  async recordQuestionAnswer(payload: RecordAnswerPayload): Promise<RecordAnswerResult> {
    try {
      logger.info(`Registrando resposta unificada: usuário ${payload.userId}, questão ${payload.questionId}`);

      // 1. Validações básicas
      await this.validatePayload(payload);

      // 2. Salvar resposta detalhada com métricas de tempo
      const response = await this.saveEnhancedResponse(payload);

      // 3. Atualizar registro de retenção (análise de padrão)
      const retentionUpdate = await this.updateRetentionRecord(payload);

      // 4. Se é revisão FSRS, atualizar algoritmo
      if (payload.context === ResponseContext.FSRS_REVIEW && payload.fsrsCardId) {
        await this.updateFSRSCard(payload);
      }

      // 5. Calcular recomendação inteligente baseada em padrão
      const shouldRecommend = await this.calculateFSRSRecommendation(retentionUpdate);

      // 6. Análise de eficiência temporal
      const timeEfficiency = await this.analyzeTimeEfficiency(payload.userId, payload.questionId);

      logger.info(`Resposta unificada processada com sucesso: ${response.id}`);

      return {
        response,
        retentionUpdate,
        shouldRecommendFSRS: shouldRecommend,
        timeEfficiencyFeedback: timeEfficiency
      };

    } catch (error) {
      logger.error('Erro ao registrar resposta unificada:', error);
      if (error instanceof AppError) {
        throw error;
      }
      throw new AppError('Erro ao processar resposta da questão', 500);
    }
  }

  /**
   * Gerar estatísticas completas da lista
   */
  async generateListStatistics(listId: string, userId: string): Promise<ListCompletionStatistics> {
    try {
      logger.info(`Gerando estatísticas da lista ${listId} para usuário ${userId}`);

      // Buscar todas as respostas da lista
      const responses = await this.getListResponses(listId, userId);

      if (responses.length === 0) {
        throw new AppError('Nenhuma resposta encontrada para esta lista', 404);
      }

      // Calcular métricas básicas
      const basic = this.calculateBasicMetrics(responses);

      // Calcular eficiência temporal
      const timeEfficiency = this.calculateTimeEfficiency(responses);

      // Analisar retenção baseada em histórico existente
      const retention = await this.analyzeRetentionInList(responses, userId);

      // Analisar padrões temporais
      const patterns = this.analyzeTemporalPatterns(responses);

      // Gerar recomendações inteligentes
      const recommendations = await this.generateIntelligentRecommendations(responses, retention);

      const statistics: ListCompletionStatistics = {
        listId,
        userId,
        sessionId: uuidv4(), // Gerar ID único para esta sessão
        basic,
        timeEfficiency,
        retention,
        patterns,
        recommendations,
        completedAt: Timestamp.now()
      };

      logger.info(`Estatísticas da lista geradas: ${statistics.basic.accuracyPercentage}% de acerto`);

      return statistics;

    } catch (error) {
      logger.error('Erro ao gerar estatísticas da lista:', error);
      if (error instanceof AppError) {
        throw error;
      }
      throw new AppError('Erro ao gerar estatísticas da lista', 500);
    }
  }

  /**
   * Adicionar questões selecionadas ao FSRS
   */
  async addSelectedQuestionsToFSRS(
    questionIds: string[],
    userId: string,
    strategy: 'ALL' | 'INCORRECT_ONLY' | 'CORRECT_ONLY' | 'INTELLIGENT_SELECTION' = 'INTELLIGENT_SELECTION'
  ): Promise<{
    success: boolean;
    addedCount: number;
    skippedCount: number;
    fsrsCards: Array<{ questionId: string; fsrsCardId: string; nextReview: Date }>;
  }> {
    try {
      logger.info(`Adicionando questões ao FSRS: ${questionIds.length} questões, estratégia ${strategy}`);

      const results = {
        success: true,
        addedCount: 0,
        skippedCount: 0,
        fsrsCards: [] as Array<{ questionId: string; fsrsCardId: string; nextReview: Date }>
      };

      for (const questionId of questionIds) {
        try {
          // Verificar se deve adicionar baseado na estratégia
          const shouldAdd = await this.shouldAddToFSRSBasedOnStrategy(questionId, userId, strategy);

          if (!shouldAdd) {
            results.skippedCount++;
            continue;
          }

          // Verificar se já existe no FSRS
          const existingCard = await this.fsrsService.getCardByFlashcardId(questionId, userId);
          if (existingCard) {
            logger.info(`Questão ${questionId} já está no FSRS`);
            results.skippedCount++;
            continue;
          }

          // Criar card FSRS
          const fsrsCard = this.fsrsService.createNewCard(questionId, userId, 'questions');
          await this.fsrsService.saveCard(fsrsCard);

          // Atualizar resposta mais recente para indicar que está no FSRS
          await this.updateLatestResponseFSRSStatus(questionId, userId, fsrsCard.id);

          results.addedCount++;
          results.fsrsCards.push({
            questionId,
            fsrsCardId: fsrsCard.id,
            nextReview: fsrsCard.due
          });

        } catch (error) {
          logger.error(`Erro ao adicionar questão ${questionId} ao FSRS:`, error);
          results.skippedCount++;
        }
      }

      logger.info(`FSRS batch concluído: ${results.addedCount} adicionadas, ${results.skippedCount} puladas`);

      return results;

    } catch (error) {
      logger.error('Erro ao adicionar questões ao FSRS:', error);
      throw new AppError('Erro ao adicionar questões ao sistema de revisão', 500);
    }
  }

  // =============================================================================
  // MÉTODOS PRIVADOS - IMPLEMENTAÇÃO DETALHADA
  // =============================================================================

  /**
   * Validar payload de entrada
   */
  private async validatePayload(payload: RecordAnswerPayload): Promise<void> {
    if (!payload.userId) {
      throw new AppError('ID do usuário é obrigatório', 400);
    }
    if (!payload.questionId) {
      throw new AppError('ID da questão é obrigatório', 400);
    }
    if (payload.isCorrect === undefined) {
      throw new AppError('É necessário informar se a resposta está correta', 400);
    }
    if (!payload.timeMetrics) {
      throw new AppError('Métricas de tempo são obrigatórias', 400);
    }
    if (!payload.sessionMetrics) {
      throw new AppError('Métricas de sessão são obrigatórias', 400);
    }

    // Verificar se a questão existe
    const question = await this.questionService.getQuestionById(payload.questionId);
    if (!question) {
      throw new AppError('Questão não encontrada', 404);
    }
  }

  /**
   * Salvar resposta expandida no banco
   */
  private async saveEnhancedResponse(payload: RecordAnswerPayload): Promise<EnhancedQuestionResponse> {
    const id = uuidv4();
    const now = Timestamp.now();

    const response: EnhancedQuestionResponse = {
      id,
      userId: payload.userId,
      questionId: payload.questionId,
      selectedAlternativeId: payload.selectedAlternativeId,
      isCorrect: payload.isCorrect,
      answeredAt: now,
      context: payload.context,
      questionListId: payload.questionListId || null,
      timeMetrics: payload.timeMetrics,
      isInReviewSystem: payload.fsrsCardId !== null && payload.fsrsCardId !== undefined,
      fsrsCardId: payload.fsrsCardId || null,
      lastReviewQuality: payload.lastReviewQuality,
      sessionMetrics: payload.sessionMetrics,
      createdAt: now,
      updatedAt: now
    };

    await this.db.collection(ENHANCED_QUESTION_RESPONSES_COLLECTION).doc(id).set(response);

    return response;
  }

  /**
   * Atualizar registro de retenção
   */
  private async updateRetentionRecord(payload: RecordAnswerPayload): Promise<QuestionRetentionRecord> {
    const attempt: RetentionAttempt = {
      date: Timestamp.now(),
      correct: payload.isCorrect,
      context: payload.context,
      responseTimeMs: payload.timeMetrics.totalTimeMs,
      confidence: this.inferConfidenceFromTime(payload.timeMetrics)
    };

    return await this.retentionService.updateRetention(
      payload.userId,
      payload.questionId,
      attempt
    );
  }

  /**
   * Atualizar card FSRS se aplicável
   */
  private async updateFSRSCard(payload: RecordAnswerPayload): Promise<void> {
    if (!payload.fsrsCardId || !payload.lastReviewQuality) {
      return;
    }

    const fsrsGrade = this.convertReviewQualityToFSRSGrade(payload.lastReviewQuality);
    
    await this.fsrsService.reviewCard(
      payload.questionId,
      payload.userId,
      fsrsGrade,
      payload.timeMetrics.totalTimeMs
    );
  }

  /**
   * Calcular recomendação FSRS baseada em padrão de retenção
   */
  private async calculateFSRSRecommendation(retention: QuestionRetentionRecord): Promise<boolean> {
    // Recomendar FSRS se:
    // 1. Questão está em fase de REGRESSION
    // 2. Taxa de retenção baixa (< 70%)
    // 3. Muitas tentativas incorretas consecutivas (> 3)

    if (retention.learningPattern.phase === 'REGRESSION') {
      return true;
    }

    if (retention.metrics.retentionRate < 0.7) {
      return true;
    }

    const recentAttempts = retention.attempts.slice(-3);
    const allIncorrect = recentAttempts.every(attempt => !attempt.correct);
    if (allIncorrect && recentAttempts.length >= 3) {
      return true;
    }

    return false;
  }

  /**
   * Analisar eficiência temporal individual
   */
  private async analyzeTimeEfficiency(userId: string, questionId: string): Promise<string> {
    // Buscar histórico de respostas desta questão pelo usuário
    const responses = await this.getQuestionResponses(questionId, userId);
    
    if (responses.length < 2) {
      return "Primeira resposta registrada para análise temporal";
    }

    const correctResponses = responses.filter(r => r.isCorrect);
    const incorrectResponses = responses.filter(r => !r.isCorrect);

    if (correctResponses.length === 0 || incorrectResponses.length === 0) {
      return "Dados insuficientes para análise de eficiência temporal";
    }

    const avgTimeCorrect = correctResponses.reduce((sum, r) => sum + r.timeMetrics.totalTimeMs, 0) / correctResponses.length / 1000;
    const avgTimeIncorrect = incorrectResponses.reduce((sum, r) => sum + r.timeMetrics.totalTimeMs, 0) / incorrectResponses.length / 1000;

    const ratio = avgTimeIncorrect / avgTimeCorrect;

    if (ratio > 2.0) {
      return `Você gasta ${ratio.toFixed(1)}x mais tempo nas questões que erra. Considere seguir em frente mais rápido.`;
    } else if (ratio < 0.8) {
      return `Você responde rapidamente questões que acerta. Pode estar chutando algumas?`;
    } else {
      return `Bom equilíbrio temporal: ${Math.round(avgTimeCorrect)}s para acertar, ${Math.round(avgTimeIncorrect)}s para errar.`;
    }
  }

  /**
   * Calcular métricas básicas da lista
   */
  private calculateBasicMetrics(responses: EnhancedQuestionResponse[]): {
    totalQuestions: number;
    correctAnswers: number;
    accuracyPercentage: number;
    totalTimeMs: number;
    averageTimePerQuestion: number;
  } {
    const totalQuestions = responses.length;
    const correctAnswers = responses.filter(r => r.isCorrect).length;
    const accuracyPercentage = Math.round((correctAnswers / totalQuestions) * 100);
    const totalTimeMs = responses.reduce((sum, r) => sum + r.timeMetrics.totalTimeMs, 0);
    const averageTimePerQuestion = Math.round(totalTimeMs / totalQuestions);

    return {
      totalQuestions,
      correctAnswers,
      accuracyPercentage,
      totalTimeMs,
      averageTimePerQuestion
    };
  }

  /**
   * Calcular eficiência temporal da lista
   */
  private calculateTimeEfficiency(responses: EnhancedQuestionResponse[]): TimeEfficiencyAnalysis {
    const correct = responses.filter(r => r.isCorrect);
    const incorrect = responses.filter(r => !r.isCorrect);

    if (correct.length === 0 || incorrect.length === 0) {
      return {
        correctQuestions: { averageTimeSeconds: 0, count: correct.length },
        incorrectQuestions: { averageTimeSeconds: 0, count: incorrect.length },
        pattern: 'BALANCED',
        timeRatio: 1,
        userMessage: "Dados insuficientes para análise temporal",
        recommendation: "Continue respondendo questões para análise",
        interpretation: {
          message: "Análise temporal será disponível com mais dados",
          advice: "Continue praticando",
          pattern: "INSUFFICIENT_DATA"
        }
      };
    }

    const avgTimeCorrect = correct.reduce((sum, r) => sum + r.timeMetrics.totalTimeMs, 0) / correct.length / 1000;
    const avgTimeIncorrect = incorrect.reduce((sum, r) => sum + r.timeMetrics.totalTimeMs, 0) / incorrect.length / 1000;

    const ratio = avgTimeIncorrect / avgTimeCorrect;

    let pattern: 'OVERTHINKING_INCORRECT' | 'RUSHING_CORRECT' | 'BALANCED';
    let recommendation: string;

    if (ratio > 2.0) {
      pattern = 'OVERTHINKING_INCORRECT';
      recommendation = 'Considere seguir em frente mais rápido nas questões difíceis';
    } else if (ratio < 0.8) {
      pattern = 'RUSHING_CORRECT';
      recommendation = 'Você pode estar respondendo muito rapidamente questões que acerta';
    } else {
      pattern = 'BALANCED';
      recommendation = 'Bom equilíbrio entre tempo e precisão';
    }

    return {
      correctQuestions: { averageTimeSeconds: Math.round(avgTimeCorrect), count: correct.length },
      incorrectQuestions: { averageTimeSeconds: Math.round(avgTimeIncorrect), count: incorrect.length },
      pattern,
      timeRatio: ratio,
      userMessage: `Tempo médio para acertar: ${Math.round(avgTimeCorrect/60)}min${Math.round(avgTimeCorrect%60)}s | errar: ${Math.round(avgTimeIncorrect/60)}min${Math.round(avgTimeIncorrect%60)}s`,
      recommendation,
      interpretation: {
        message: `Você está gastando ${ratio.toFixed(1)}x mais tempo nas questões que erra`,
        advice: recommendation,
        pattern
      }
    };
  }

  /**
   * Analisar retenção na lista baseada em histórico
   */
  private async analyzeRetentionInList(responses: EnhancedQuestionResponse[], userId: string): Promise<RetentionAnalysis> {
    const consistencyAnalysis = [];
    let questionsSeenBefore = 0;
    let questionsNewToUser = 0;
    let improvementCount = 0;
    let regressionCount = 0;

    for (const response of responses) {
      const retention = await this.retentionService.getRetentionRecord(userId, response.questionId);
      
      if (!retention || retention.attempts.length <= 1) {
        questionsNewToUser++;
        continue;
      }

      questionsSeenBefore++;
      
      // Comparar com tentativa anterior
      const previousAttempts = retention.attempts.slice(0, -1);
      const lastPreviousAttempt = previousAttempts[previousAttempts.length - 1];
      
      if (lastPreviousAttempt) {
        let trend: 'IMPROVED' | 'MAINTAINED' | 'REGRESSED';
        let message: string;

        if (!lastPreviousAttempt.correct && response.isCorrect) {
          trend = 'IMPROVED';
          message = 'Melhorou! Acertou uma questão que errava antes';
          improvementCount++;
        } else if (lastPreviousAttempt.correct && !response.isCorrect) {
          trend = 'REGRESSED';
          message = 'Regrediu. Errou uma questão que acertava antes';
          regressionCount++;
        } else {
          trend = 'MAINTAINED';
          message = lastPreviousAttempt.correct ? 'Manteve acerto' : 'Manteve erro';
        }

        consistencyAnalysis.push({
          questionId: response.questionId,
          previousResult: lastPreviousAttempt.correct,
          currentResult: response.isCorrect,
          trend,
          message
        });
      }
    }

    const retentionRate = questionsSeenBefore > 0 
      ? responses.filter(r => r.isCorrect).length / questionsSeenBefore 
      : 0;

    const improvementRate = questionsSeenBefore > 0 
      ? improvementCount / questionsSeenBefore 
      : 0;

    return {
      questionsSeenBefore,
      questionsNewToUser,
      retentionRate: Math.round(retentionRate * 100) / 100,
      improvementRate: Math.round(improvementRate * 100) / 100,
      regressionCount,
      consistencyAnalysis
    };
  }

  /**
   * Analisar padrões temporais
   */
  private analyzeTemporalPatterns(responses: EnhancedQuestionResponse[]): TemporalPatterns {
    const accuracyByPosition = responses.map(r => r.isCorrect ? 1 : 0);
    const timeByPosition = responses.map(r => r.timeMetrics.totalTimeMs);

    // Detectar fadiga baseada na performance ao longo da lista
    let fatigueEffect: 'NONE' | 'MILD' | 'MODERATE' | 'SEVERE' = 'NONE';
    
    if (responses.length >= 10) {
      const firstHalf = responses.slice(0, Math.floor(responses.length / 2));
      const secondHalf = responses.slice(Math.floor(responses.length / 2));
      
      const firstHalfAccuracy = firstHalf.filter(r => r.isCorrect).length / firstHalf.length;
      const secondHalfAccuracy = secondHalf.filter(r => r.isCorrect).length / secondHalf.length;
      
      const accuracyDrop = firstHalfAccuracy - secondHalfAccuracy;
      
      if (accuracyDrop > 0.3) {
        fatigueEffect = 'SEVERE';
      } else if (accuracyDrop > 0.2) {
        fatigueEffect = 'MODERATE';
      } else if (accuracyDrop > 0.1) {
        fatigueEffect = 'MILD';
      }
    }

    // Sugerir tamanho ótimo de sessão baseado na performance
    let optimalSessionLength = responses.length;
    
    if (fatigueEffect !== 'NONE') {
      // Se há fadiga, sugerir sessões menores
      optimalSessionLength = Math.max(10, Math.floor(responses.length * 0.7));
    }

    return {
      accuracyByPosition,
      timeByPosition,
      fatigueEffect,
      optimalSessionLength
    };
  }

  /**
   * Gerar recomendações inteligentes
   */
  private async generateIntelligentRecommendations(
    responses: EnhancedQuestionResponse[], 
    retention: RetentionAnalysis
  ): Promise<IntelligentRecommendations> {
    const shouldAddToFSRS = [];
    const focusAreas = [];

    // Analisar cada questão para recomendações FSRS
    for (const response of responses) {
      let reason: 'CONSISTENTLY_INCORRECT' | 'REGRESSION' | 'HIGH_VALUE_TOPIC' | null = null;
      let priority: 'HIGH' | 'MEDIUM' | 'LOW' = 'LOW';

      // Questão incorreta
      if (!response.isCorrect) {
        reason = 'CONSISTENTLY_INCORRECT';
        priority = 'HIGH';
      }

      // Verificar se houve regressão
      const regressionItem = retention.consistencyAnalysis.find(
        item => item.questionId === response.questionId && item.trend === 'REGRESSED'
      );
      
      if (regressionItem) {
        reason = 'REGRESSION';
        priority = 'HIGH';
      }

      if (reason) {
        shouldAddToFSRS.push({
          questionId: response.questionId,
          reason,
          priority
        });
      }
    }

    // Gerar recomendação de gestão de tempo
    const avgTime = responses.reduce((sum, r) => sum + r.timeMetrics.totalTimeMs, 0) / responses.length;
    const timeManagement = avgTime > 180000 // 3 minutos
      ? "Tente ser mais decisivo em questões difíceis"
      : avgTime < 30000 // 30 segundos
        ? "Considere ler as questões com mais atenção"
        : "Bom ritmo de resposta";

    // Sugerir próximo tempo de estudo (24h depois)
    const nextStudyTime = Timestamp.fromDate(new Date(Date.now() + 24 * 60 * 60 * 1000));

    return {
      shouldAddToFSRS,
      focusAreas,
      nextStudyTime,
      timeManagement
    };
  }

  // =============================================================================
  // MÉTODOS AUXILIARES
  // =============================================================================

  /**
   * Buscar respostas de uma lista
   */
  private async getListResponses(listId: string, userId: string): Promise<EnhancedQuestionResponse[]> {
    const snapshot = await this.db
      .collection(ENHANCED_QUESTION_RESPONSES_COLLECTION)
      .where('userId', '==', userId)
      .where('questionListId', '==', listId)
      .where('context', '==', ResponseContext.LIST_STUDY)
      .orderBy('answeredAt', 'asc')
      .get();

    return snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id } as EnhancedQuestionResponse));
  }

  /**
   * Buscar respostas de uma questão específica
   */
  private async getQuestionResponses(questionId: string, userId: string): Promise<EnhancedQuestionResponse[]> {
    const snapshot = await this.db
      .collection(ENHANCED_QUESTION_RESPONSES_COLLECTION)
      .where('userId', '==', userId)
      .where('questionId', '==', questionId)
      .orderBy('answeredAt', 'asc')
      .get();

    return snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id } as EnhancedQuestionResponse));
  }

  /**
   * Inferir nível de confiança baseado no tempo de resposta
   */
  private inferConfidenceFromTime(timeMetrics: TimeMetrics): 'LOW' | 'MEDIUM' | 'HIGH' {
    const totalSeconds = timeMetrics.totalTimeMs / 1000;
    
    if (totalSeconds < 30) {
      return 'HIGH'; // Resposta rápida = alta confiança
    } else if (totalSeconds < 120) {
      return 'MEDIUM'; // Tempo moderado = confiança média
    } else {
      return 'LOW'; // Muito tempo = baixa confiança
    }
  }

  /**
   * Converter ReviewQuality para FSRSGrade
   */
  private convertReviewQualityToFSRSGrade(quality: ReviewQuality): FSRSGrade {
    switch (quality) {
      case ReviewQuality.AGAIN:
        return FSRSGrade.AGAIN;
      case ReviewQuality.HARD:
        return FSRSGrade.HARD;
      case ReviewQuality.GOOD:
        return FSRSGrade.GOOD;
      case ReviewQuality.EASY:
        return FSRSGrade.EASY;
      default:
        return FSRSGrade.GOOD;
    }
  }

  /**
   * Verificar se deve adicionar ao FSRS baseado na estratégia
   */
  private async shouldAddToFSRSBasedOnStrategy(
    questionId: string, 
    userId: string, 
    strategy: string
  ): Promise<boolean> {
    if (strategy === 'ALL') {
      return true;
    }

    // Buscar última resposta da questão
    const responses = await this.getQuestionResponses(questionId, userId);
    if (responses.length === 0) {
      return false;
    }

    const lastResponse = responses[responses.length - 1];

    switch (strategy) {
      case 'INCORRECT_ONLY':
        return !lastResponse.isCorrect;
      
      case 'CORRECT_ONLY':
        return lastResponse.isCorrect;
      
      case 'INTELLIGENT_SELECTION':
        // Usar dados de retenção para decidir
        const retention = await this.retentionService.getRetentionRecord(userId, questionId);
        if (!retention) {
          return !lastResponse.isCorrect; // Se não tem histórico, adicionar se errou
        }
        
        // Adicionar se: taxa de retenção baixa OU em regressão OU erro recente
        return retention.metrics.retentionRate < 0.7 || 
               retention.learningPattern.phase === 'REGRESSION' ||
               !lastResponse.isCorrect;
      
      default:
        return true;
    }
  }

  /**
   * Atualizar status FSRS da resposta mais recente
   */
  private async updateLatestResponseFSRSStatus(questionId: string, userId: string, fsrsCardId: string): Promise<void> {
    const responses = await this.getQuestionResponses(questionId, userId);
    if (responses.length === 0) {
      return;
    }

    const latestResponse = responses[responses.length - 1];
    
    await this.db
      .collection(ENHANCED_QUESTION_RESPONSES_COLLECTION)
      .doc(latestResponse.id)
      .update({
        isInReviewSystem: true,
        fsrsCardId: fsrsCardId,
        updatedAt: Timestamp.now()
      });
  }
} 